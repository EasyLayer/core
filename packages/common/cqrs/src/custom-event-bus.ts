import type { IEventHandler, ICommand, ISaga } from '@nestjs/cqrs';
import { UnhandledExceptionBus, EventBus, CommandBus } from '@nestjs/cqrs';
import type { Type } from '@nestjs/common';
import { Logger, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { defer, of, Subject, Observable, tap, from } from 'rxjs';
import { catchError, concatMap, filter } from 'rxjs/operators';
import { EVENTS_HANDLER_METADATA, SAGA_METADATA } from '@nestjs/cqrs/dist/decorators/constants';
import type { UnhandledExceptionInfo } from '@nestjs/cqrs/dist/interfaces';
import { InvalidSagaException } from '@nestjs/cqrs/dist/exceptions/invalid-saga.exception';
import type { DomainEvent } from './basic-event';

export type EventHandlerType<E extends DomainEvent = DomainEvent> = Type<IEventHandler<E>>;

@Injectable()
export class CustomEventBus<E extends DomainEvent = DomainEvent> extends EventBus<E> {
  private readonly _newLogger = new Logger(CustomEventBus.name);
  private readonly _eventHandlerCompletion$ = new Subject<E>();
  private readonly _sagaCompletion$ = new Subject<E>();

  constructor(
    private readonly ingectCommandBus: CommandBus,
    private readonly injectedModuleRef: ModuleRef,
    private readonly injectedUnhandledExceptionBus: UnhandledExceptionBus
  ) {
    super(ingectCommandBus, injectedModuleRef, injectedUnhandledExceptionBus);
  }

  /**
   * Returns an Observable that allows tracking events
   * processed by the event handler.
   *
   * @returns Observable<E> - An Observable that emits events after they have been processed.
   */
  get eventHandlerCompletion$(): Observable<E> {
    return this._eventHandlerCompletion$.asObservable();
  }

  /**
   * Returns an Observable that allows tracking events
   * processed by the saga.
   *
   * @returns Observable<E> - An Observable that emits events after they have been processed by the saga.
   */
  get sagaCompletion$(): Observable<E> {
    return this._sagaCompletion$.asObservable();
  }

  async publish<T extends E, TContext = unknown>(event: T, context?: TContext) {
    await this.publisher.publish(event, context);
  }

  async publishAll<T extends E, TContext = unknown>(events: T[], context?: TContext) {
    if (this.publisher.publishAll) {
      await this.publisher.publishAll(events, context);
    } else {
      // await Promise.all(events.map((event) => this.publisher.publish(event, context)));
      for (const event of events) {
        await this.publisher.publish(event, context);
      }
    }
  }

  bind(handler: IEventHandler<E>, id: string) {
    // IMPORTANT: method ofEventId() filtering events by metadata id field.
    // id is a value generated by the @EventHandler() decorator,
    // that is assigned handler to a specific event type.
    // In our system we overwrite this id with own metadata as name of event constructor.
    // (The EventHandler decorator acts as a two-in-one, it is a decorator for both the EventHandler and the Event)
    // (a specific event type - this means that the handler will work using this id with all events from one class).
    // (all events of this type will have the same id).
    const stream$ = id ? this.ofEventId(id) : this.subject$;
    const subscription = stream$
      .pipe(
        concatMap((event) =>
          defer(() =>
            from(handler.handle(event)).pipe(
              // Notify about completion of processing
              tap(() => this._eventHandlerCompletion$.next(event)),
              catchError((error) => {
                this._eventHandlerCompletion$.error(error);
                const unhandledError = this.mapUnhandledExceptionEvent(event, error);
                this.injectedUnhandledExceptionBus.publish(unhandledError);
                return of();
              })
            )
          )
        )
      )
      .subscribe();
    this.subscriptions.push(subscription);
  }

  registerSagas(types: Type<unknown>[] = []) {
    const sagas = types
      .map((target) => {
        const metadata = Reflect.getMetadata(SAGA_METADATA, target) || [];
        // TODO: Provide the correct type
        const instance: any = this.injectedModuleRef.get(target, { strict: false });
        if (!instance) {
          throw new InvalidSagaException();
        }
        return metadata.map((key: string) => instance[key].bind(instance));
      })
      .reduce((a, b) => a.concat(b), []);

    // TODO: Provide the correct type
    sagas.forEach((saga: any) => this.registerSaga(saga));
  }

  protected registerSaga(saga: ISaga<E>) {
    if (typeof saga !== 'function') {
      throw new InvalidSagaException();
    }
    const stream$ = saga(this);
    if (!(stream$ instanceof Observable)) {
      throw new InvalidSagaException();
    }

    const subscription = stream$.pipe(filter((e): e is E => e != null)).subscribe({
      next: (data) => {
        // this._newLogger.debug(`Saga result: ${data}`);
        this._sagaCompletion$.next(data);
      },
      error: (error) => {
        // this._newLogger.error(`Saga has thrown an unhandled exception: ${error}`);
        this._sagaCompletion$.error(error);
      },
      complete: () => {
        // this._newLogger.debug('Saga processing completed.');
        this._sagaCompletion$.complete();
      },
    });

    this.subscriptions.push(subscription);
  }

  protected reflectHandlersEvents(handler: EventHandlerType<E>): FunctionConstructor[] {
    return Reflect.getMetadata(EVENTS_HANDLER_METADATA, handler);
  }

  protected mapUnhandledExceptionEvent(eventOrCommand: E | ICommand, exception: unknown): UnhandledExceptionInfo {
    return {
      cause: eventOrCommand,
      exception,
    };
  }
}
